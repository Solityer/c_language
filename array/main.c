#include <stdio.h>

// ============================================================================
// 数组大小与 C99 标准 (VLA)
// ============================================================================
void study_c99_vla_concepts()
{
    printf("\n========== 数组大小与 C99 变长数组 ==========\n");
    // 原始注释保留：
    // C99 之前数组只能是常量指定大小
    // C99 之后引用了变长数组(Variable Length Array, VLA)的概念，数组的大小是可以使用变量指定的
    // 但是 VS2022、2019 默认不支持C99的变长数组 (注：支持程度取决于编译器设置，MSVC对C标准支持较保守)

    // 常量指定大小（所有编译器支持）
    int arr[5];
    int arr2[3 + 2]; // 表达式结果为常量，合法

    printf("标准数组定义测试通过：arr[5], arr2[3+2]\n");

    /* // 下面的代码在支持 C99 VLA 的编译器（如 GCC, Clang）中合法
    // 在默认的 MSVC (VS2019/2022) 中会报错，因此为了编译通过，此处保持注释状态，但逻辑保留供学习。

    int n = 0;
    printf("请输入数组大小: ");
    scanf("%d", &n);
    int arr4[n]; // 变长数组
    */
    printf("提示：变长数组代码需在支持 C99 的环境运行，VS中通常不推荐使用。\n");
}

// ============================================================================
// 一维数组的初始化规则
// ============================================================================
void study_1d_initialization()
{
    printf("\n========== 一维数组的初始化规则 ==========\n");

    // 1. 不完全初始化
    // 规则：剩余的元素默认初始化为0
    int arr[10] = {1, 2, 3};
    printf("arr[10] 不完全初始化 {1,2,3} 的内存情况:\n");
    for (int i = 0; i < 10; i++)
    {
        printf("%d ", arr[i]);
    }
    printf("\n");

    // 2. 完全初始化
    int arr2[5] = {1, 2, 3, 4, 5};

    // 3. 字符数组初始化
    char arr4[3] = {'a', 98, 'c'}; // 98 是 'b' 的 ASCII 码
    printf("char arr4[3] 内容: %c, %c, %c\n", arr4[0], arr4[1], arr4[2]);

    // 4. 省略数组大小（根据初始化内容自动推断）
    int arr3[] = {1, 2, 3};
    int sz_arr3 = sizeof(arr3) / sizeof(arr3[0]);
    printf("arr3[] 省略大小时自动推断的长度: %d\n", sz_arr3);

    // 5. 特殊初始化技巧
    int arr5[10] = {0}; // 全0

    // 6. 字符串初始化对比
    char arr7[] = {'a', 'b', 'c'}; // 这是一个字符数组，大小为3，没有结束符 \0
    char arr8[] = "abc"; // 这是一个字符串，大小为4，包含隐藏的 \0

    printf("sizeof(arr7) [字符数组]: %zu\n", sizeof(arr7));
    printf("sizeof(arr8) [字符串]:   %zu (包含 \\0)\n", sizeof(arr8));
}

// ============================================================================
// 一维数组的遍历与内存地址
// ============================================================================
void study_1d_memory_layout()
{
    printf("\n========== 一维数组的遍历与内存地址 ==========\n");

    int arr[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
    // 索引:      0  1  2  3  4  5  6  7  8  9

    int sz = sizeof(arr) / sizeof(arr[0]);
    int i = 0;

    // 打印每个元素的地址，验证数组在内存中是连续存放的
    // int 类型通常占 4 个字节，所以地址应该相差 4
    printf("打印数组元素地址 (注意观察地址的增长):\n");
    for (i = 0; i < sz; i++)
    {
        printf("&arr[%d] = %p\n", i, &arr[i]);
    }
}

// ============================================================================
// 二维数组的逻辑与物理存储
// ============================================================================
void study_2d_arrays()
{
    printf("\n========== 二维数组详解 ==========\n");

    // 1. 初始化
    // 对于二维数组，如果初始化了，对于行数是可以省略的，但是列不能省略
    int arr_implicit[][10] = {{1, 2}, {2, 3, 4}, {5, 5, 5}}; // 自动推断为 3 行

    // 2. 标准初始化与遍历
    int arr[3][5] = {{1, 2}, {4, 5}, {6, 7, 8}}; // 不完全初始化，未指定位置补0
    int i = 0;
    int j = 0;

    printf("二维数组 arr[3][5] 的内容:\n");
    for (i = 0; i < 3; i++)
    {
        for (j = 0; j < 5; j++)
        {
            printf("%d ", arr[i][j]);
        }
        printf("\n");
    }

    // 3. 二维数组的内存布局
    // 逻辑上是二维的，物理上在内存中是连续的一维线性空间
    printf("二维数组的内存地址:\n");
    for (i = 0; i < 3; i++)
    {
        for (j = 0; j < 5; j++)
        {
            printf("&arr[%d][%d] = %p\n", i, j, &arr[i][j]);
        }
    }
}

// ============================================================================
// 数组名、地址与指针的本质 (核心难点)
// ============================================================================
void study_array_names_and_pointers()
{
    printf("\n========== 数组名与指针的规则 ==========\n");

    // 核心结论：
    // 数组名就是地址，通常来说：数组名是数组首元素的地址
    // 但是有2个例外：
    // 1. sizeof(数组名)：这里的数组名表示整个数组，计算的是整个数组的大小，单位是字节
    // 2. &数组名：这里的数组名表示整个数组，取出的是整个数组的地址
    // 除此之外，所有遇到的数组名都是数组首元素的地址

    int arr[10] = {0};

    printf("arr (首元素地址):        %p\n", arr);
    printf("arr + 1 (跳过一个int):   %p\n", arr + 1);

    printf("&arr[0] (首元素地址):    %p\n", &arr[0]);
    printf("&arr[0] + 1:             %p\n", &arr[0] + 1);

    printf("--------------------------------\n");
    printf("&arr (整个数组的地址):   %p\n", &arr);
    printf("&arr + 1 (跳过整个数组): %p\n", &arr + 1);

    // 解释：
    // arr + 1 跳过 4 字节 (sizeof(int))
    // &arr + 1 跳过 40 字节 (sizeof(int) * 10)

    printf("sizeof(arr) = %zu 字节\n", sizeof(arr));
}

// ============================================================================
// 数组作为函数参数 (冒泡排序)
// ============================================================================

// 数组传参时，传递的是首元素的地址
// 所以形参写成 int arr[] 或者 int *arr 本质都是指针
// void sort(int arr[], int sz) // 这种写法也可以
void bubble_sort(int *arr, int sz)
{
    int i = 0;
    // 外层循环：确定冒泡的趟数
    for (i = 0; i < sz - 1; i++)
    {
        int j = 0;
        // 内层循环：每一趟比较的对数
        for (j = 0; j < sz - 1 - i; j++)
        {
            if (arr[j] > arr[j + 1]) // 升序排序
            {
                // 交换
                int tmp = arr[j];
                arr[j] = arr[j + 1];
                arr[j + 1] = tmp;
            }
        }
    }
}

void study_array_parameter_passing()
{
    printf("\n========== 模块 6: 数组传参 (冒泡排序) ==========\n");

    int arr[] = {10, 9, 8, 7, 6, 5, 4, 3, 2, 1}; // 降序数组
    int sz = sizeof(arr) / sizeof(arr[0]); // 必须在主调函数中计算大小

    printf("排序前: ");
    for (int i = 0; i < sz; i++)
        printf("%d ", arr[i]);
    printf("\n");

    // 调用排序
    // arr 这里不属于那2种特殊情况，所以传递的是数组首元素的地址
    bubble_sort(arr, sz);

    printf("排序后: ");
    for (int i = 0; i < sz; i++)
        printf("%d ", arr[i]);
    printf("\n");
}

int main()
{
    study_c99_vla_concepts();
    study_1d_initialization();
    study_1d_memory_layout();
    study_2d_arrays();
    study_array_names_and_pointers();
    study_array_parameter_passing();
    return 0;
}
