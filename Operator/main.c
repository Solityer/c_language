#include <stdio.h>
#include <time.h>
#include <stdlib.h>

// ---------------------------------------------------------------------------
// 基本算术运算与数据截断
// ---------------------------------------------------------------------------
void test_arithmetic_truncation()
{
    printf("=== 测试：算术运算与截断 ===\n");

    // 除法运算的整数截断特性
    // int m = 7.0 / 2.0; // 结果虽为3.5，但存入int会被截断为3
    // double n = 7.0 / 2.0; // 3.500000

    // 取模运算
    int m = 7 % 2; // 结果为1
    printf("7 %% 2 = %d\n", m);

    // 数据截断示例
    int a = (int) 3.14; // 3.14 被编译器识别为double，强制转为int丢失精度
    printf("int(3.14) = %d\n", a);
}

// ---------------------------------------------------------------------------
// 移位操作符 (<<, >>) 与原码、反码、补码
// ---------------------------------------------------------------------------
void test_shift_operators()
{
    printf("\n=== 测试：移位操作符与补码 ===\n");

    // 左移操作：左边丢弃，右边补0
    // 正数示例：7
    // 原码/补码：00000000000000000000000000000111
    int m_pos = 7;
    int n_pos = m_pos << 1;
    // 移位后：00000000000000000000000000001110 (14)
    printf("7 << 1 = %d\n", n_pos);

    // 负数示例：-7
    int m_neg = -7;
    // 原码：10000000000000000000000000000111
    // 反码：11111111111111111111111111111000
    // 补码：11111111111111111111111111111001 (内存中存储的形式)

    int n_neg = m_neg << 1;
    // 左移1位：11111111111111111111111111110010 (补码)
    // 转反码：11111111111111111111111111110001
    // 转原码：10000000000000000000000000001110 (-14)
    printf("-7 << 1 = %d\n", n_neg);

    // 右移操作：算术右移通常是补符号位
    int a = -10;
    int b = a >> 1;
    printf("-10 >> 1 = %d\n", b); // -5
}

// ---------------------------------------------------------------------------
// 位操作符 (&, |, ^, ~)
// ---------------------------------------------------------------------------
void test_bitwise_logic()
{
    printf("\n=== 测试：位逻辑操作符 ===\n");
    int a = 3;
    int b = -5;

    // a (3)  补码: 00000000000000000000000000000011
    // b (-5) 补码: 11111111111111111111111111111011 (原码 1...101 -> 反 1...10 -> 补 1...11)

    // 1. 按位与 (&)
    int c_and = a & b;
    // 运算：000...0011 & 111...1011 = 000...0011 (3)
    printf("3 & -5 = %d\n", c_and);

    // 2. 按位或 (|)
    int c_or = a | b;
    // 运算：000...0011 | 111...1011 = 111...1011 (-5)
    printf("3 | -5 = %d\n", c_or);

    // 3. 按位异或 (^) - 相同为0，相异为1
    int c_xor = a ^ b;
    // 运算：000...0011 ^ 111...1011 = 111...1000
    // 补码 1...1000 -> 反码 1...0111 -> 原码 1...1000 (-8)
    printf("3 ^ -5 = %d\n", c_xor);

    // 4. 按位取反 (~)
    int d = 0;
    // 0的补码：00000000000000000000000000000000
    // 取反后：11111111111111111111111111111111 (补码，代表-1)
    printf("~0 = %d\n", ~d);
}

// ---------------------------------------------------------------------------
// 位运算的经典算法应用
// ---------------------------------------------------------------------------

// 算法1：不使用临时变量交换两个数
void swap_without_temp()
{
    printf("\n=== 算法：不使用临时变量交换数值 ===\n");
    int a = 3;
    int b = 5;
    printf("交换前: a=%d b=%d\n", a, b);

    // 核心原理：a^a = 0, 0^a = a
    a = a ^ b; // a 存储了 a和b 的差异信息
    b = a ^ b; // b = (a^b)^b = a^0 = a (b变为了原来的a)
    a = a ^ b; // a = (a^b)^a = b^0 = b (a变为了原来的b)

    printf("交换后: a=%d b=%d\n", a, b);
}

// 算法2：统计二进制中1的个数
// 方法：n = n & (n - 1) 每次运算会把二进制最右边的1变成0
int count_num_of_1(int n)
{
    int count = 0;
    while (n)
    {
        n = n & (n - 1);
        count++;
    }
    return count;
}

// 算法3：统计两个整数二进制位不同的个数
int count_diff_bit(int m, int n)
{
    // 异或结果中为1的位，即为两者不同的位
    int r = m ^ n;
    // 复用统计1的个数的逻辑
    return count_num_of_1(r);
}

// 算法4：打印整数二进制的奇数位和偶数位
void print_odd_even_bits(int n)
{
    printf("数字 %d 的二进制位分析:\n", n);
    int i = 0;
    // 奇数位 (从高位到低位打印，便于阅读)
    printf("奇数位: ");
    for (i = 30; i >= 0; i -= 2)
    {
        printf("%d ", (n >> i) & 1);
    }
    printf("\n");
    // 偶数位
    printf("偶数位: ");
    for (i = 31; i >= 1; i -= 2)
    {
        printf("%d ", (n >> i) & 1);
    }
    printf("\n");
}

// ---------------------------------------------------------------------------
// sizeof、数组与内存
// ---------------------------------------------------------------------------

// 数组参数退化测试
void test_array_param(int arr[])
{
    // 此时 arr 只是一个指针，在32位系统下大小为4，64位下为8
    // 而不是整个数组的大小
    printf("函数内部 sizeof(arr) = %zd (指针大小)\n", sizeof(arr));
}

void test_arrays_memory()
{
    printf("\n=== 测试：数组与sizeof ===\n");
    int a = 10;
    printf("sizeof(a) = %zd\n", sizeof(a));
    printf("sizeof(int) = %zd\n", sizeof(int));

    int arr[10] = {0};
    printf("数组总大小 sizeof(arr) = %zd\n", sizeof(arr));
    printf("元素大小 sizeof(arr[0]) = %zd\n", sizeof(arr[0]));
    printf("数组元素个数 = %zd\n", sizeof(arr) / sizeof(arr[0]));

    test_array_param(arr);
}

// 数组逆置函数
void reverse_array(int arr[], int sz)
{
    int left = 0;
    int right = sz - 1;
    while (left < right)
    {
        int tmp = arr[left];
        arr[left] = arr[right];
        arr[right] = tmp;
        left++;
        right--;
    }
}

// ---------------------------------------------------------------------------
// 操作符副作用与未定义行为 (Undefined Behavior)
// ---------------------------------------------------------------------------
void test_side_effects()
{
    printf("\n=== 测试：操作符副作用与优先级 ===\n");

    // 自增自减
    int a = 5;
    int b = ++a; // 前置++: 先+1, 后使用 (a=6, b=6)
    printf("前置++: a=%d, b=%d\n", a, b);

    a = 5;
    b = a++; // 后置++: 先使用, 后+1 (b=5, a=6)
    printf("后置++: a=%d, b=%d\n", a, b);

    // 短路操作测试
    // && 左边为假，右边不计算； || 左边为真，右边不计算
    int i = 0, x = 0, y = 2, z = 3, d = 4;
    i = x++ || ++y || d++;
    // x++是0(假)，继续算 ++y
    // ++y是3(真)，逻辑或成立，d++ 不执行（短路）
    // 最终：x=1, y=3, d=4, i=1
    printf("短路测试: x=%d y=%d d=%d i=%d\n", x, y, d, i);

    // 【注意】以下代码是存在问题的（未定义行为），不同编译器结果可能不同
    // int val = 1;
    // int ret = (++val) + (++val) + (++val);
    // 这种写法严重依赖编译器实现，严禁在工程中使用。
}

// ---------------------------------------------------------------------------
// 整型提升与类型转换
// ---------------------------------------------------------------------------
void test_integer_promotion()
{
    printf("\n=== 测试：整型提升 (Integer Promotion) ===\n");
    // char 类型参与运算时会先提升为 int
    char a = 5;
    // 00000101
    char b = 126;
    // 01111110

    char c = a + b;
    // 计算过程（提升为int）：
    // a: 0000...00000101
    // b: 0000...00111110
    // + ----------------
    // r: 0000...10000011 (131)
    // 截断回char c: 10000011

    // 打印时 %d 需要按int解释：
    // c (10000011) 符号位是1，整型提升补1
    // 补码: 1111...10000011
    // 反码: 1111...10000010
    // 原码: 1000...01111101 -> -125
    printf("char c = a + b -> %d\n", c);

    // 比较大小时也会发生整型提升
    char x = 0xb6;
    if (x == 0xb6)
        printf("x == 0xb6\n");
    else
        printf("x != 0xb6 (因为0xb6是int型正数，而char 0xb6提升后是负数)\n");
}

// ---------------------------------------------------------------------------
// 结构体 (Struct)
// ---------------------------------------------------------------------------
struct Book
{
    char name[20];
    int price;
};

void print_book(struct Book *pb)
{
    // 结构体指针访问成员的两种方式
    printf("结构体指针访问: %s %d\n", (*pb).name, (*pb).price);
    printf("箭头操作符访问: %s %d\n", pb->name, pb->price);
}

void test_struct()
{
    printf("\n=== 测试：结构体 ===\n");
    struct Book b = {"C语言指南", 55};
    // 结构体变量.成员
    printf("普通变量访问: %s %d\n", b.name, b.price);
    print_book(&b);
}


int main()
{
    test_arithmetic_truncation();
    test_shift_operators();
    test_bitwise_logic();

    // 位操作算法测试
    swap_without_temp();

    int num = -1; // 测试全1的情况
    printf("数字 %d 二进制中1的个数: %d\n", num, count_num_of_1(num));

    int m = 1999, n = 2299;
    printf("数字 %d 和 %d 二进制位不同的个数: %d\n", m, n, count_diff_bit(m, n));

    print_odd_even_bits(10); // 10 -> 1010

    test_arrays_memory();
    test_side_effects();
    test_integer_promotion();
    test_struct();

    // 随机数示例（保留原文件逻辑）
    // srand((unsigned int)time(NULL));
    // rand();

    return 0;
}
