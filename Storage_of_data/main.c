#include <stdio.h>
#include <string.h>
#include <windows.h> // 用于 Sleep 函数

// ==========================================================================
// 模块一：整数在内存中的存储 (原码、反码、补码)
// ==========================================================================
/*
 * 知识点：
 * 1. 计算机内存中整型存储的是【补码】。
 * 2. 正数的原码、反码、补码相同。
 * 3. 负数的求补码规则：原码符号位不变，其他位按位取反得到反码，反码+1得到补码。
 * 4. %x 打印十六进制，%d 打印有符号十进制，%u 打印无符号十进制。
 */
void test_integer_storage()
{
    printf("=== 测试：整数存储与补码 ===\n");

    // 情况1：有符号负数
    int a = -10;
    // 内存分析 (32位 int):
    // 原码: 10000000 00000000 00000000 00001010 (-10)
    // 反码: 11111111 11111111 11111111 11110101 (符号位不变，其余取反)
    // 补码: 11111111 11111111 11111111 11110110 (反码 + 1) -> 内存中的实际值
    // 十六进制视图:  F   F    F    F    F    F    F    6  -> 0xFFFFFFF6

    // 情况2：无符号数赋值负数 (位模式相同，但解释方式不同)
    unsigned int b = -10;
    // 补码: 11111111 11111111 11111111 11110110
    // 对于 unsigned int，最高位被视为数值位而非符号位，这是一个非常大的正数。

    printf("int a = -10 (Hex): %x\n", a); // 输出: fffffff6
    printf("unsigned int b = -10 (Hex): %x\n", b); // 输出: fffffff6
    printf("\n");
}

// ==========================================================================
// 模块二：整数加法的底层逻辑
// ==========================================================================
/*
 * 知识点：
 * CPU 只有加法器，减法通过加负数的补码来实现。
 */
void test_integer_addition()
{
    printf("=== 测试：整数加法 (1 + -1) ===\n");
    // 计算 1 + (-1)
    // 1 的补码:  00000000 00000000 00000000 00000001
    // -1 的补码: 11111111 11111111 11111111 11111111
    // 相加:     100000000 00000000 00000000 00000000 (产生进位，最高位溢出丢弃)
    // 结果:      00000000 00000000 00000000 00000000 -> 0

    int i = 1;
    int j = -1;
    printf("1 + (-1) = %d\n\n", i + j);
}

// ==========================================================================
// 模块三：大小端字节序判断
// ==========================================================================
/*
 * 知识点：
 * 大端模式 (Big Endian): 数据的低位保存在内存的高地址中。
 * 小端模式 (Little Endian): 数据的低位保存在内存的低地址中。
 * 常用面试题：设计一个程序判断当前机器的字节序。
 */

// 辅助函数：判断系统字节序
int check_sys()
{
    int a = 1;
    // 1 的补码 (Hex): 0x 00 00 00 01
    // 小端存储: 01 00 00 00 (低地址存低位 01)
    // 大端存储: 00 00 00 01 (低地址存高位 00)

    char *p = (char *) &a; // 获取低地址处的第一个字节

    // 如果取出的第一个字节是 1，说明低位在低地址 -> 小端
    return *p;
}

void test_endianness()
{
    printf("=== 测试：大小端判断 ===\n");
    int a = 0x11223344;
    // 内存观察参考：
    // 小端: 44 33 22 11
    // 大端: 11 22 33 44

    if (check_sys() == 1)
    {
        printf("当前系统为：小端 (Little Endian)\n");
    }
    else
    {
        printf("当前系统为：大端 (Big Endian)\n");
    }
    printf("\n");
}

// ==========================================================================
// 模块四：整型提升与截断 (char 类型的行为)
// ==========================================================================
/*
 * 知识点：
 * 1. 截断：将长整型赋值给短整型时，高位丢弃，保留低位。
 * 2. 整型提升 (Integer Promotion)：
 * - 有符号 char 提升时，按符号位填充高位。
 * - 无符号 char 提升时，高位补 0。
 */
void test_char_truncation_promotion()
{
    printf("=== 测试：char 类型的截断与提升 ===\n");

    // 测试 1: -1 在不同 char 类型中的表现
    char a = -1;
    signed char b = -1;
    unsigned char c = -1;

    // -1 (int) 补码: 11111111 11111111 11111111 11111111
    // 赋值给 char 发生截断 -> 11111111 (8 bit)

    // 打印时发生整型提升:
    // a (signed): 符号位是1 -> 补1 -> 11111111...11111111 -> -1
    // b (signed): 同上 -> -1
    // c (unsigned): 无符号提升高位补0 -> 00000000...11111111 -> 255

    printf("a=%d, b=%d, c=%d\n", a, b, c);
    // 输出: a=-1, b=-1, c=255

    // 测试 2: -128 的打印
    char d = -128;
    // -128 原码: 10000000 (8bit下特殊规定)
    // 补码:      10000000
    // 整型提升 (signed): 符号位1 -> 11111111 11111111 11111111 10000000
    // %u 打印 (视为无符号数): 上述二进制对应的十进制大数
    printf("char -128 using %%u: %u\n", d); // 输出: 4294967168

    // 测试 3: 128 的截断
    char e = 128;
    // 128 (int): 0000...0000 10000000
    // 截断存入 e: 10000000
    // 此时 e 被视为有符号 char，最高位 1 为符号位。
    // 整型提升: 11111111...10000000
    // %u 打印: 同上
    printf("char 128 using %%u: %u\n", e); // 输出: 4294967168
    printf("\n");
}

// ==========================================================================
// 模块五：算术转换 (隐式类型转换)
// ==========================================================================
/*
 * 知识点：
 * 当有符号数 (int) 和无符号数 (unsigned int) 进行运算时，
 * 有符号数会被隐式转换为无符号数。
 */
void test_implicit_conversion()
{
    printf("=== 测试：有符号与无符号混合运算 ===\n");
    int i = -20;
    unsigned int j = 10;

    // i (-20) 补码: 11111111 11111111 11111111 11101100
    // j (10)  补码: 00000000 00000000 00000000 00001010

    // 加法运算按位进行:
    //   11111111 11111111 11111111 11101100
    // + 00000000 00000000 00000000 00001010
    // -------------------------------------
    //   11111111 11111111 11111111 11110110

    // 结果解释:
    // %d (有符号): 看到最高位是1，认为是负数，求原码 -> -10
    // %u (无符号): 这是一个非常大的正数

    printf("i + j = %d (expected -10)\n", i + j);
    printf("\n");
}

// ==========================================================================
// 模块六：循环中的陷阱 (unsigned 与 溢出)
// ==========================================================================
/*
 * 知识点：
 * 1. unsigned int 永远 >= 0，作为循环终止条件极易导致死循环。
 * 2. unsigned char 范围 0~255，i++ 到 256 会变回 0，导致死循环。
 * 3. strlen 依赖 \0，利用 char 溢出构造逻辑题。
 */
void test_loop_pitfalls()
{
    printf("=== 测试：循环与数据类型陷阱 ===\n");

    // 陷阱 1: unsigned int 的倒序循环
    /* unsigned int u_i;
    // 警告：此循环为死循环。当 u_i 为 0 时，0-1 变为最大无符号整数 (0xFFFFFFFF)，依然 >= 0。
    for (u_i = 9; u_i >= 0; u_i--) {
        printf("%u\n", u_i);
        Sleep(100);
    }
    */
    printf("提示：Unsigned int >= 0 循环已注释以防死循环。\n");

    // 陷阱 2: strlen 与 char 溢出
    // 逻辑：a[i] = -1, -2, -3 ... -128, 127, 126 ... 0
    // char 范围 -128 ~ 127。
    // 当数值变为 0 时，strlen 停止计数。
    // -1 到 -128 (128个)
    // 127 到 1 (127个)
    // 下一个是 0。
    // 总长度 = 128 + 127 = 255。
    char a[1000];
    int i;
    for (i = 0; i < 1000; i++)
    {
        a[i] = -1 - i;
    }
    printf("strlen(a) 的结果: %d (expected 255)\n", strlen(a));

    // 陷阱 3: unsigned char 范围死循环
    /*
    unsigned char uc = 0;
    // 警告：此循环为死循环。255 + 1 -> 0，永远 <= 255。
    for (uc = 0; uc <= 255; uc++) {
        printf("hello world\n");
    }
    */
    printf("提示：Unsigned char <= 255 循环已注释以防死循环。\n");
    printf("\n");
}

// ==========================================================================
// 模块七：浮点数存储规则 (IEEE 754)
// ==========================================================================
/*
 * 知识点：
 * float (32位) 存储规则: (-1)^S * M * 2^E
 * - S (1 bit): 符号位
 * - E (8 bit): 指数位 (存真实值 + 127)
 * - M (23 bit): 有效数字 (1.xxxxx，省略掉前面的1)
 *
 * 核心差异：整数 9 和浮点数 9.0 在内存中的二进制模式完全不同。
 */
void test_float_storage()
{
    printf("=== 测试：浮点数 IEEE 754 存储 ===\n");

    int n = 9;
    // 整数 9 的内存补码:
    // 00000000 00000000 00000000 00001001

    float *pFloat = (float *) &n; // 强制将这块内存当作 float 解析

    printf("n的值为：%d\n", n); // 正常打印整数 9

    // 当作 float 解析:
    // S=0, E=00000000, M=00000000000000000001001
    // 指数全0 (非规格化数/接近0)，这是一个极其小的数
    printf("*pFloat的值为：%f (expected 0.000000)\n", *pFloat);

    *pFloat = 9.0;
    // 浮点数 9.0 的二进制表示:
    // 9.0 (DEC) -> 1001.0 (BIN) -> 1.001 * 2^3
    // S = 0
    // E = 3 + 127 = 130 -> 10000010
    // M = 00100000000000000000000 (去掉开头的1，补齐23位)
    // 组合: 0 10000010 00100000000000000000000

    // 当作 int 解析:
    // 01000001 00010000 00000000 00000000 -> 0x41100000
    // 十进制: 1,091,567,616

    printf("修改 *pFloat = 9.0 后，n (int) 的值为：%d\n", n);
    printf("*pFloat的值为：%f\n", *pFloat);

    // 补充例子：5.5 的存储
    // 5.5 -> 101.1 -> 1.011 * 2^2
    // S=0, E=2+127=129 (10000001), M=01100...
    // 内存: 0 10000001 01100000000000000000000 -> 0x40B00000
}

int main()
{
    test_integer_storage(); // 模块1：整数补码
    test_integer_addition(); // 模块2：整数加法逻辑
    test_endianness(); // 模块3：大小端判断
    test_char_truncation_promotion(); // 模块4：Char截断与提升
    test_implicit_conversion(); // 模块5：隐式转换
    test_loop_pitfalls(); // 模块6：循环陷阱 (strlen等)
    test_float_storage(); // 模块7：浮点数存储
    return 0;
}
