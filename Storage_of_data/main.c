#include <stdio.h>
#include <limits.h>
#include <string.h>

// ==========================================================================
// 模块一：整数的底层存储逻辑 (The Representation of Integers)
// ==========================================================================
/*
 * [核心原理]
 * 计算机内存中，整数一律以【补码 (Two's Complement)】形式存储。
 * * [为什么使用补码？]
 * 1. 统一加减法：CPU 中只需要设计加法器 (Adder)。减法 A - B 等价于 A + (-B)。
 * 2. 解决 +0 和 -0 的二义性：原码中 0000 和 1000 都表示0，补码完美解决了这个问题。
 * * [转换规则]
 * - 正数：原码 = 反码 = 补码
 * - 负数：
 * 1. 原码：符号位为1，其余位为数值绝对值。
 * 2. 反码：符号位不变，数值位按位取反。
 * 3. 补码：反码 + 1。
 */
void study_integer_storage()
{
    printf("\n=== 模块一：整数存储与补码逻辑 ===\n");

    // 案例 A: 负数的存储
    // 这是一个 32 位有符号整数
    int num = -10;

    /* * 内存位级分析 (-10):
     * 1. 原码: 10000000 00000000 00000000 00001010
     * 2. 反码: 11111111 11111111 11111111 11110101 (符号位不变，其余取反)
     * 3. 补码: 11111111 11111111 11111111 11110110 (反码 + 1) -> 存入内存的值
     * * 十六进制视图 (Hex): F  F  F  F  F  F  F  6
     */
    printf("int num = -10\n");
    printf("内存十六进制表示: 0x%x (注意: %%x 输出的是内存中的补码)\n", num);

    // 案例 B: 补码加法演示 (CPU 如何计算 1 - 1)
    // 1 - 1 其实是 1 + (-1)
    /*
     * 1 的补码:  00000000 00000000 00000000 00000001
     * -1 的补码: 11111111 11111111 11111111 11111111
     * ---------------------------------------------------
     * 相加结果: 100000000 00000000 00000000 00000000
     * * 注意：最高位的 1 溢出了 (32位存不下)，被丢弃。
     * 剩余结果:  00000000 ... 00000000 -> 结果为 0。
     * 这就是补码设计的精妙之处，溢出恰好保证了运算的正确性。
     */
    int i = 1;
    int j = -1;
    printf("1 + (-1) = %d\n", i + j);
}

// ==========================================================================
// 模块二：大小端字节序 (Endianness)
// ==========================================================================
/*
 * [核心原理]
 * 大小端描述的是“多字节数据”在内存地址中存放的顺序。
 * * - 小端 (Little Endian): 低位字节存放在低地址，高位字节存放在高地址。(x86, ARM常用)
 * - 大端 (Big Endian): 高位字节存放在低地址，低位字节存放在高地址。(网络传输常用)
 * * [记忆口诀] 小小低低：小端在低地址存低位。
 * * [科研场景]
 * 在 ZKP 中，当你序列化一个大整数（BigInt）传输给验证者（Verifier）时，
 * 必须明确字节序，否则对方解析出的数值会完全错误。
 */

// 检测函数：返回 1 为小端，0 为大端
int check_sys()
{
    int i = 1;
    // int i = 1 的内存 (32位): 0x 00 00 00 01
    // 小端模式: 01 00 00 00 (低地址 -> 高地址)
    // 大端模式: 00 00 00 01 (低地址 -> 高地址)

    // (char*)&i 拿到了低地址的第一个字节
    return (*(char *) &i);
}

void study_endianness()
{
    printf("\n=== 模块二：大小端字节序检测 ===\n");

    int a = 0x11223344;
    printf("变量 a = 0x11223344\n");

    char *p = (char *) &a;
    printf("内存低地址处第一个字节内容: 0x%x\n", *p); // 只是为了展示

    if (check_sys() == 1)
    {
        printf("结论: 当前机器是【小端存储】(Little Endian)\n");
        printf("内存布局验证: [低地址] 44 33 22 11 [高地址]\n");
    }
    else
    {
        printf("结论: 当前机器是【大端存储】(Big Endian)\n");
        printf("内存布局验证: [低地址] 11 22 33 44 [高地址]\n");
    }
}

// ==========================================================================
// 模块三：整型提升与截断 (Promotion & Truncation)
// ==========================================================================
/*
 * [核心原理]
 * 1. 截断 (Truncation): 将长字节类型赋值给短字节类型（如 int -> char）。
 * 直接切掉高位，只保留低位。
 * * 2. 整型提升 (Integer Promotion): CPU 运算器通常是 32位或64位的。
 * 在计算或打印时，char/short 会被提升为 int。
 * - 有符号提升: 高位补符号位 (Sign Extension)。
 * - 无符号提升: 高位补 0 (Zero Extension)。
 */
void study_char_promotion()
{
    printf("\n=== 模块三：整型提升与截断 ===\n");

    // 步骤1: 赋值与截断
    char a = -1;
    signed char b = -1;
    unsigned char c = -1;
    /*
     * -1 的 int 补码: 11111111 11111111 11111111 11111111
     * 赋值给 char (8 bit) -> 发生截断:
     * a, b, c 在内存中存的都是: 11111111 (0xFF)
     */

    // 步骤2: 打印时的整型提升
    printf("数值展示:\n");

    // 分析 a (signed char): 11111111
    // 符号位是1 -> 提升时高位全补1 -> 1111...1111 -> 补码(-1)
    printf("a = %d (signed char 提升)\n", a);

    // 分析 c (unsigned char): 11111111
    // 无符号数 -> 提升时高位全补0 -> 0000...11111111 -> 正数(255)
    printf("c = %d (unsigned char 提升)\n", c);

    printf("c = %u (unsigned char 以无符号形式打印)\n", c);

    // 陷阱案例: 128
    // 128 的 int: 000...010000000
    // char d = -128; // 10000000
    // 打印 %u 时，先提升为有符号 int (因为 char 默认通常是有符号的)，再被 %u 解释
    char d = -128;
    // 10000000 -> 提升(补1) -> 11111111...10000000
    // %u 把它看作一个巨大的正数
    printf("char -128 as %%u: %u (整型提升的副作用)\n", d);
}

// ==========================================================================
// 模块四：算术转换与循环陷阱
// ==========================================================================
/*
 * [核心原理]
 * 当 有符号数 (int) 与 无符号数 (unsigned) 进行运算时，
 * 有符号数会被隐式转换为无符号数！
 * * 这是 ZKP 电路约束代码中常见的 Bug 来源：
 * 如果你写 `if (x - y < 0)` 但 x, y 是无符号数，结果将永远为假（因为结果也是无符号）。
 */
void study_arithmetic_conversion()
{
    printf("\n=== 模块四：隐式算术转换 ===\n");

    int i = -20;
    unsigned int j = 10;

    // i + j 
    // i 补码: 1111...11101100 (-20)
    // j 补码: 0000...00001010 (10)
    // 相加:   1111...11110110
    // 结果被视为 unsigned int (很大的正数) 还是 int (-10)?
    // 取决于你怎么解释结果，但计算过程是按位加的。

    // %d 会把结果强制解释为有符号
    // %u 会展示真实的无符号值
    printf("i + j (as %%d) = %d\n", i + j);
    printf("i + j (as %%u) = %u (看到了吗？这是一个巨大的正数)\n", i + j);

    // 经典循环陷阱：strlen 的溢出应用
    // char 范围: -128 ~ 127
    // 赋值序列: -1, -2, ... -128, 127, 126, ... 1, 0
    // 长度计算: 128个负数 + 127个正数 = 255。遇到 0 时 strlen 停止。
    char str_arr[1000];
    int k;
    for (k = 0; k < 1000; k++)
    {
        str_arr[k] = -1 - k;
    }
    printf("strlen结果: %zu (原理：char溢出循环回到0)\n", strlen(str_arr));
}

// ==========================================================================
// 模块五：浮点数存储 (IEEE 754)
// ==========================================================================
/*
 * [核心原理]
 * 浮点数 (float) 并非像整数那样直接存值，而是存公式：
 * V = (-1)^S * M * 2^E
 * * 内存布局 (32位 float):
 * - S (1位): 符号位 (Sign)
 * - E (8位): 指数位 (Exponent), 存真实值 + 127 (Bias)
 * - M (23位): 有效数字 (Mantissa), 实际上是 1.xxxx，1 被省略了
 */
void study_float_storage()
{
    printf("\n=== 模块五：浮点数 IEEE 754 ===\n");

    int n = 9;
    // 9 的整数补码: 00000000 00000000 00000000 00001001

    float *pFloat = (float *) &n;

    printf("整数 9 作为 int 打印: %d\n", n);

    // 当我们强行把这个二进制序列当 float 看时：
    // S=0
    // E=00000000 (全0，代表这是一个极小的非规格化数)
    // M=...0001001
    // 结果无限接近于 0
    printf("整数 9 作为 float 打印: %f (解释错误，非预期转换)\n", *pFloat);

    *pFloat = 9.0;
    // 9.0 的二进制: 1001.0 -> 1.001 * 2^3
    // S = 0
    // E = 3 + 127 = 130 -> 二进制 10000010
    // M = 001 0000... (补齐23位)
    // 内存中的样子: 0 10000010 00100000000000000000000

    printf("将 float 9.0 存入内存后...\n");
    printf("作为 float 打印: %f\n", *pFloat);

    // 如果把上面那串二进制当 int 读出来：
    // 0100 0001 0001 0000 ... -> 0x41100000
    printf("作为 int 打印: %d (这是 9.0 的 IEEE 754 二进制表示对应的十进制)\n", n);
}

int main()
{
    // 按顺序学习各个模块
    study_integer_storage();
    study_endianness();
    study_char_promotion();
    study_arithmetic_conversion();
    study_float_storage();

    return 0;
}
